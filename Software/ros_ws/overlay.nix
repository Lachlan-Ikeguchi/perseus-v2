final: prev:
let
  # ros distro selection
  rosDistro = "humble";

  # ros2nix autogenerated package overlay location
  packaging-overlay = import ./nix-packages/overlay.nix;

  patches-overlay = (import ./patches_overlay.nix) rosDistro final prev;

  patchedPrev = prev // patches-overlay;
  rosPkgs = patchedPrev.rosPackages.${rosDistro};
  # output package set
  ros = (rosPkgs.overrideScope packaging-overlay) // rosPkgs;

  # --- OTHER PACKAGES ---
  # mini package which puts COLCON_IGNORE in the output result folder
  # allows colcon build of workspace after run nix build
  colcon-ignore = prev.stdenv.mkDerivation {
    dontUnpack = true;
    name = "colcon-ignore";
    installPhase = ''
      mkdir -p $out
      touch $out/COLCON_IGNORE
    '';
  };
in
patchedPrev
// {
  # packaging for colcon clean
  pythonPackagesExtensions = prev.pythonPackagesExtensions ++ [
    (pyFinal: pyPrev: {
      colcon-clean = pyFinal.callPackage ./colcon/clean.nix { };
      scantree = pyFinal.callPackage ./colcon/scantree.nix { };
    })
  ];
  colcon = with final.python3Packages; prev.colcon.withExtensions [ colcon-clean ];

  # output package sets
  inherit ros colcon-ignore;
  rosPackages = patchedPrev.rosPackages // {
    ${rosDistro} = ros;
  };
  /*
    The intersection of the full custom package set and the workspace packages overlay
    selects the fully resolved packages out of the custom package set,
    getting us only the dev packages.

    That then gets merged with the colcon-ignore package so colcon doesn't try
    and build things from the (already built!) result symlink that nix build generates
  */
  # output dev packages to make workspace package selection easier
  rosDevPackages = (builtins.intersectAttrs (packaging-overlay null null) final.ros) // {
    inherit colcon-ignore; # always include colcon-ignore in dev packages
  };
}
