<root BTCPP_format="4">
    <TreeNodesModel>
        <Condition ID="AreErrorCodesPresent">
            <input_port name="error_codes_to_check" type="std::set&lt;unsigned short, std::less&lt;unsigned short&gt;, std::allocator&lt;unsigned short&gt; &gt;">Error codes to check</input_port>
            <input_port name="error_code" type="unsigned short">The active error codes</input_port>
        </Condition>
        <Action ID="AssistedTeleop">
            <input_port name="time_allowance" type="double" default="10.000000">Allowed time for running assisted teleop</input_port>
            <input_port name="is_recovery" type="bool" default="false">If true the recovery count will be incremented</input_port>
            <output_port name="error_code_id" type="unsigned short">The assisted teleop behavior server error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="BackUp">
            <input_port name="backup_dist" type="double" default="0.150000">Distance to backup</input_port>
            <input_port name="backup_speed" type="double" default="0.025000">Speed at which to backup</input_port>
            <input_port name="time_allowance" type="double" default="10.000000">Allowed time for reversing</input_port>
            <output_port name="error_code_id" type="unsigned short">The back up behavior server error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelAssistedTeleop">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelBackUp">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelControl">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelDriveOnHeading">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelSpin">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="CancelWait">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="ClearCostmapAroundRobot">
            <input_port name="reset_distance" type="double" default="1.000000">Distance from the robot under which obstacles are cleared</input_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="service_name" type="std::string">please_set_service_name_in_BT_Node</input_port>
        </Action>
        <Action ID="ClearCostmapExceptRegion">
            <input_port name="reset_distance" type="double" default="1.000000">Distance from the robot above which obstacles are cleared</input_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="service_name" type="std::string">please_set_service_name_in_BT_Node</input_port>
        </Action>
        <Action ID="ClearEntireCostmap">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="service_name" type="std::string">please_set_service_name_in_BT_Node</input_port>
        </Action>
        <Action ID="ComputePathThroughPoses">
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Destinations to plan through</input_port>
            <input_port name="start" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Start pose of the path if overriding current robot pose</input_port>
            <output_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path created by ComputePathThroughPoses node</output_port>
            <input_port name="planner_id" type="std::string" default="">Mapped name to the planner plugin type to use</input_port>
            <output_port name="error_code_id" type="unsigned short">The compute path through poses error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="ComputePathToPose">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Destination to plan to</input_port>
            <input_port name="start" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Start pose of the path if overriding current robot pose</input_port>
            <output_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path created by ComputePathToPose node</output_port>
            <input_port name="planner_id" type="std::string" default="">Mapped name to the planner plugin type to use</input_port>
            <output_port name="error_code_id" type="unsigned short">The compute path to pose error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="ControllerSelector">
            <output_port name="selected_controller" type="std::string">Selected controller by subscription</output_port>
            <input_port name="topic_name" type="std::string" default="controller_selector">the input topic name to select the controller</input_port>
            <input_port name="default_controller" type="std::string">the default controller to use if there is not any external topic message received.</input_port>
        </Action>
        <Decorator ID="DistanceController">
            <input_port name="robot_base_frame" type="std::string">Robot base frame</input_port>
            <input_port name="global_frame" type="std::string">Global frame</input_port>
            <input_port name="distance" type="double" default="1.000000">Distance</input_port>
        </Decorator>
        <Condition ID="DistanceTraveled">
            <input_port name="robot_base_frame" type="std::string">Robot base frame</input_port>
            <input_port name="global_frame" type="std::string">Global frame</input_port>
            <input_port name="distance" type="double" default="1.000000">Distance</input_port>
        </Condition>
        <Action ID="DriveOnHeading">
            <input_port name="speed" type="double" default="0.025000">Speed at which to travel</input_port>
            <input_port name="time_allowance" type="double" default="10.000000">Allowed time for driving on heading</input_port>
            <output_port name="error_code_id" type="unsigned short">The drive on heading behavior server error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="dist_to_travel" type="double" default="0.150000">Distance to travel</input_port>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="FollowPath">
            <input_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path to follow</input_port>
            <input_port name="controller_id" type="std::string"/>
            <input_port name="goal_checker_id" type="std::string"/>
            <input_port name="progress_checker_id" type="std::string"/>
            <output_port name="error_code_id" type="unsigned short">The follow path error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="GetPoseFromPath">
            <input_port name="index" type="int" default="0">Index of pose to extract from. -1 is end of list</input_port>
            <output_port name="pose" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Stamped Extracted Pose</output_port>
            <input_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path to extract pose from</input_port>
        </Action>
        <Condition ID="GlobalUpdatedGoal">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Navigation goal</input_port>
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Vector of navigation goals</input_port>
        </Condition>
        <Action ID="GoalCheckerSelector">
            <output_port name="selected_goal_checker" type="std::string">Selected goal_checker by subscription</output_port>
            <input_port name="topic_name" type="std::string" default="goal_checker_selector">the input topic name to select the goal_checker</input_port>
            <input_port name="default_goal_checker" type="std::string">the default goal_checker to use if there is not any external topic message received.</input_port>
        </Action>
        <Condition ID="GoalReached">
            <input_port name="robot_base_frame" type="std::string">Robot base frame</input_port>
            <input_port name="global_frame" type="std::string">Global frame</input_port>
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Destination</input_port>
        </Condition>
        <Condition ID="GoalUpdated">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Navigation goal</input_port>
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Vector of navigation goals</input_port>
        </Condition>
        <Decorator ID="GoalUpdatedController">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Navigation goal</input_port>
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Vector of navigation goals</input_port>
        </Decorator>
        <Decorator ID="GoalUpdater">
            <output_port name="output_goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Received Goal by subscription</output_port>
            <input_port name="input_goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Original Goal</input_port>
        </Decorator>
        <Condition ID="InitialPoseReceived">
            <input_port name="initial_pose_received" type="bool"/>
        </Condition>
        <Condition ID="IsBatteryCharging">
            <input_port name="battery_topic" type="std::string" default="/battery_status">Battery topic</input_port>
        </Condition>
        <Condition ID="IsBatteryLow">
            <input_port name="is_voltage" type="bool" default="false">If true voltage will be used to check for low battery</input_port>
            <input_port name="battery_topic" type="std::string" default="/battery_status">Battery topic</input_port>
            <input_port name="min_battery" type="double">Minimum battery percentage/voltage</input_port>
        </Condition>
        <Condition ID="IsPathValid">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path to Check</input_port>
        </Condition>
        <Condition ID="IsStuck"/>
        <Action ID="NavigateThroughPoses">
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Destinations to plan through</input_port>
            <input_port name="behavior_tree" type="std::string">Behavior tree to run</input_port>
            <output_port name="error_code_id" type="unsigned short">The navigate through poses error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="NavigateToPose">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Destination to plan to</input_port>
            <input_port name="behavior_tree" type="std::string">Behavior tree to run</input_port>
            <output_port name="error_code_id" type="unsigned short">Navigate to pose error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Condition ID="PathExpiringTimer">
            <input_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;"/>
            <input_port name="seconds" type="double" default="1.000000">Seconds</input_port>
        </Condition>
        <Decorator ID="PathLongerOnApproach">
            <input_port name="prox_len" type="double" default="3.000000">Proximity length (m) for the path to be longer on approach</input_port>
            <input_port name="length_factor" type="double" default="2.000000">Length multiplication factor to check if the path is significantly longer</input_port>
            <input_port name="path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Planned Path</input_port>
        </Decorator>
        <Control ID="PipelineSequence"/>
        <Action ID="PlannerSelector">
            <output_port name="selected_planner" type="std::string">Selected planner by subscription</output_port>
            <input_port name="topic_name" type="std::string" default="planner_selector">the input topic name to select the planner</input_port>
            <input_port name="default_planner" type="std::string">the default planner to use if there is not any external topic message received.</input_port>
        </Action>
        <Action ID="ProgressCheckerSelector">
            <output_port name="selected_progress_checker" type="std::string">Selected progress_checker by subscription</output_port>
            <input_port name="topic_name" type="std::string" default="progress_checker_selector">the input topic name to select the progress_checker</input_port>
            <input_port name="default_progress_checker" type="std::string">the default progress_checker to use if there is not any external topic message received.</input_port>
        </Action>
        <Decorator ID="RateController">
            <input_port name="hz" type="double" default="10.000000">Rate</input_port>
        </Decorator>
        <Control ID="RecoveryNode">
            <input_port name="number_of_retries" type="int" default="1">Number of retries</input_port>
        </Control>
        <Action ID="ReinitializeGlobalLocalization">
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="service_name" type="std::string">please_set_service_name_in_BT_Node</input_port>
        </Action>
        <Action ID="RemovePassedGoals">
            <input_port name="robot_base_frame" type="std::string">Robot base frame</input_port>
            <input_port name="global_frame" type="std::string">Global frame</input_port>
            <input_port name="radius" type="double" default="0.500000">radius to goal for it to be considered for removal</input_port>
            <output_port name="output_goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Goals with passed viapoints removed</output_port>
            <input_port name="input_goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Original goals to remove viapoints from</input_port>
        </Action>
        <Control ID="RoundRobin"/>
        <Decorator ID="SingleTrigger"/>
        <Action ID="SmoothPath">
            <input_port name="unsmoothed_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path to be smoothed</input_port>
            <input_port name="smoother_id" type="std::string"/>
            <output_port name="smoothed_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path smoothed by SmootherServer node</output_port>
            <output_port name="smoothing_duration" type="double">Time taken to smooth path</output_port>
            <output_port name="was_completed" type="bool">True if smoothing was not interrupted by time limit</output_port>
            <input_port name="max_smoothing_duration" type="double" default="3.000000">Maximum smoothing duration</input_port>
            <input_port name="check_for_collisions" type="bool" default="false">If true collision check will be performed after smoothing</input_port>
            <output_port name="error_code_id" type="unsigned short">The smooth path error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Action ID="SmootherSelector">
            <output_port name="selected_smoother" type="std::string">Selected smoother by subscription</output_port>
            <input_port name="topic_name" type="std::string" default="smoother_selector">the input topic name to select the smoother</input_port>
            <input_port name="default_smoother" type="std::string">the default smoother to use if there is not any external topic message received.</input_port>
        </Action>
        <Decorator ID="SpeedController">
            <input_port name="goal" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Navigation goal</input_port>
            <input_port name="goals" type="std::vector&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;, std::allocator&lt;geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;">Vector of navigation goals</input_port>
            <input_port name="max_speed" type="double" default="0.500000">Maximum speed</input_port>
            <input_port name="max_rate" type="double" default="1.000000">Maximum rate</input_port>
            <input_port name="min_speed" type="double" default="0.000000">Minimum speed</input_port>
            <input_port name="min_rate" type="double" default="0.100000">Minimum rate</input_port>
        </Decorator>
        <Action ID="Spin">
            <input_port name="spin_dist" type="double" default="1.570000">Spin distance</input_port>
            <input_port name="time_allowance" type="double" default="10.000000">Allowed time for spinning</input_port>
            <input_port name="is_recovery" type="bool" default="true">True if recovery</input_port>
            <output_port name="error_code_id" type="unsigned short">The spin behavior error code</output_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Condition ID="TimeExpired">
            <input_port name="seconds" type="double" default="1.000000">Seconds</input_port>
        </Condition>
        <Condition ID="TransformAvailable">
            <input_port name="parent" type="std::string" default="">parent frame for transform</input_port>
            <input_port name="child" type="std::string" default="">Child frame for transform</input_port>
        </Condition>
        <Action ID="TruncatePath">
            <input_port name="distance" type="double" default="1.000000">distance</input_port>
            <output_port name="output_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path truncated to a certain distance</output_port>
            <input_port name="input_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Original Path</input_port>
        </Action>
        <Action ID="TruncatePathLocal">
            <input_port name="transform_tolerance" type="double" default="0.200000">Transform lookup tolerance</input_port>
            <input_port name="max_robot_pose_search_dist" type="double" default="inf">Maximum forward integrated distance along the path (starting from the last detected pose) to bound the search for the closest pose to the robot. When set to infinity (default), whole path is searched every time</input_port>
            <input_port name="robot_frame" type="std::string" default="base_link">Robot base frame id</input_port>
            <input_port name="pose" type="geometry_msgs::msg::PoseStamped_&lt;std::allocator&lt;void&gt; &gt;">Manually specified pose to be usedif overriding current robot pose</input_port>
            <input_port name="distance_backward" type="double" default="4.000000">Distance in backward direction</input_port>
            <input_port name="distance_forward" type="double" default="8.000000">Distance in forward direction</input_port>
            <input_port name="angular_distance_weight" type="double" default="0.000000">Weight of angular distance relative to positional distance when finding which path pose is closest to robot. Not applicable on paths without orientations assigned</input_port>
            <output_port name="output_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Path truncated to a certain distance around robot</output_port>
            <input_port name="input_path" type="nav_msgs::msg::Path_&lt;std::allocator&lt;void&gt; &gt;">Original Path</input_port>
        </Action>
        <Action ID="Wait">
            <input_port name="wait_duration" type="double" default="1.000000">Wait time</input_port>
            <input_port name="server_timeout" type="std::chrono::milliseconds"/>
            <input_port name="server_name" type="std::string">Action server name</input_port>
        </Action>
        <Condition ID="WouldAControllerRecoveryHelp">
            <input_port name="error_codes_to_check" type="std::set&lt;unsigned short, std::less&lt;unsigned short&gt;, std::allocator&lt;unsigned short&gt; &gt;">Error codes to check</input_port>
            <input_port name="error_code" type="unsigned short">The active error codes</input_port>
        </Condition>
        <Condition ID="WouldAPlannerRecoveryHelp">
            <input_port name="error_codes_to_check" type="std::set&lt;unsigned short, std::less&lt;unsigned short&gt;, std::allocator&lt;unsigned short&gt; &gt;">Error codes to check</input_port>
            <input_port name="error_code" type="unsigned short">The active error codes</input_port>
        </Condition>
        <Condition ID="WouldASmootherRecoveryHelp">
            <input_port name="error_codes_to_check" type="std::set&lt;unsigned short, std::less&lt;unsigned short&gt;, std::allocator&lt;unsigned short&gt; &gt;">Error codes to check</input_port>
            <input_port name="error_code" type="unsigned short">The active error codes</input_port>
        </Condition>
    </TreeNodesModel>
</root>

